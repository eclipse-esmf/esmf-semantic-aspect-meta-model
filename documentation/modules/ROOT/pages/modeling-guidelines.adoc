////
Copyright (c) 2023 Robert Bosch Manufacturing Solutions GmbH

See the AUTHORS file(s) distributed with this work for additional information regarding authorship.

This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/
SPDX-License-Identifier: MPL-2.0
////

:page-partial:

[[aspects]]
= Aspects

== General

=== Notes

* As mentioned in the xref:index.adoc[Introduction], Aspect Models are described in RDF Turtle
  xref:samm-specification:appendix:bibliography.adoc#turtle[[turtle\]]. The aspect specification will
  therefore assume basic familiarity with Turtle.
* For the definition of the different Model elements please refer to the
  xref:meta-model-elements.adoc[Meta Model Elements].


[[naming-rules]]
=== Naming rules

The naming of Model Elements follows the naming
https://en.wikipedia.org/wiki/Naming_convention_(programming)#Java[Java naming conventions] for
classes, properties and methods.

* The names of Aspects, Entities, Events, Constraints and Characteristics follow the naming conventions for
  Java classes, i.e. UpperCamelCase.
* The names of Properties, Operations and Units follow the naming conventions of Java methods, i.e.
  lowerCamelCase.

[[rdf-turtle-formatting-rules]]
=== RDF/Turtle formatting rules

* Each Aspect Model is defined in a separate TTL (Turtle) file.
* The Turtle file containing an Aspect Model must have the same name as the Aspect.
* Aspect Model files must be UTF-8 encoded and should not contain a
  https://en.wikipedia.org/wiki/Byte_order_mark[byte order mark].
* There should be one empty line between model element definitions.
* Indentation should be done with three spaces.
* There should be a space before every separating semicolon.
* There should be padding spaces inside RDF lists and anonymous nodes (i.e. inside brackets and
  square brackets)

[[attributes-that-all-model-elements-have]]
=== Attributes that all model elements have

Every model element (Aspects, Properties, Characteristics, Entities, Operations) has the following
attributes:

[width="100%", options="header", cols="30,60,10"]
|===
| Attributes | Description | Required
| `samm:preferredName` | Human readable name in a specific language. This attribute may be defined
  multiple times for different languages but only once for a specific language. There should be at
  least one preferredName defined with an "en" language tag. | {nok}
| `samm:description` | Human readable description in a specific language. This attribute may be
  defined multiple times for different languages but only once for a specific language. There should
  be at least one description defined with an "en" language tag. | {nok}
| `samm:see` | A reference to a related element in an external taxonomy, ontology or other standards
  document. The datatype is `xsd:anyURI`. This attribute may be defined multiple times. | {nok}
|===

NOTE: Although both `samm:preferredName` and `samm:description` should be set at least once in every
model element, in the following examples we will mostly leave them out to improve readability.

[[declaring-model-elements]]
== Declaring model elements

[[using-namespaces]]
=== Using Namespaces

An Aspect Model file should start with the {meta-model-abbr} prefix definitions. The empty namespace
":" should be used as local namespace, i.e. the versioned namespace in which the Aspect and its
elements are defined. Other customer or domain specific namespaces can be defined additionally.
However, the samm-* namespaces are reserved for the meta model. Third party locations can be
referred via other namespaces (e.g., "xsd:"). See
xref:namespaces.adoc#namespaces-and-versions[Namespaces and Versions] for more details on the topic.

[source,turtle,subs="attributes+,+quotes"]
----
@prefix : <urn:samm:{example-ns}.myapplication:1.0.0#> .
@prefix samm: <{samm}> .
@prefix samm-c: <{samm-c}> .
@prefix samm-e: <{samm-e}> .
@prefix unit: <{unit}> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
----

[[declaring-namespaces]]
=== Declaring Namespaces

A Namespace defines the scope in which other model elements, including Aspects,
are declared. Explicit declarations of Namespaces are not required, they
exist implicitly by declaring model elements in them. However, the explicit
declaration of a Namespace is useful if you want to assign human-readable names or
descriptions to it.

[source,turtle,subs="attributes+,+quotes"]
----
@prefix : urn:samm:{example-ns}.myapplication:1.0.0# .
@prefix samm: <{samm}> .

# The colon denotes the namespace as defined in the first @prefix declaration above.
: a samm:Namespace ;
   samm:preferredName "..."@en ;
   samm:description "..."@en .
----

[[declaring-aspects]]
=== Declaring Aspects

An Aspect is defined by marking its identifier with `a samm:Aspect` and additional attributes. Note
that the `a` is just a https://www.w3.org/TR/turtle/#sec-iri[syntactic shortcut] for `rdf:type`. In
addition to the general attributes, every Aspect Model element has the following attributes:

[width="100%", options="header"]
|===
| Attributes | Description | Required
| `samm:properties` | The list of Properties of this Aspect. Leaving out this
  attribute completely is equivalent to having it present with an empty list as value. | {nok}
| `samm:operations` | The list of Operations of this Aspect. Leaving out this
  attribute completely is equivalent to having it present with an empty list as value. | {nok}
| `samm:events` | The list of Events of this Aspect. | {nok}
|===

* Aspects follow the naming conventions for Java classes, i.e. UpperCamelCase.
* Each Aspect Model must be defined in its own file. The file name must be the same as the Aspect's
  name.
* The hierarchical namespace part in the Aspect's URN can be freely chosen.

The definition of an Aspect should therefore have the following structure in TTL syntax; note though
that unused namespaces can be left out:

[source,turtle,subs="attributes+,+quotes"]
----
@prefix : <urn:samm:{example-ns}.myapplication:1.0.0#> .
@prefix samm: <{samm}> .
@prefix samm-c: <{samm-c}> .
@prefix samm-e: <{samm-e}> .
@prefix unit: <{unit}> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

include::example$aspect-sample.ttl[tags=aspect-declaration]
----

[[declaring-properties]]
=== Declaring Properties

In addition to the xref:modeling-guidelines#declaring-model-elements#attributes-that-all-model-elements-have[attributes
that all model elements have], Properties have the following attributes:

[width="100%", options="header"]
|===
| Attributes | Description | Required
| `samm:characteristic` | The xref:characteristics.adoc#characteristics[Characteristic] describing
  this Property. | {ok}
| `samm:exampleValue` | An exemplary value the Property can take on that helps to understand the
intended meaning of the property better. This can only be set for Properties with scalar data types
(e.g., `xsd:string` or `xsd:float`, but not Entities). The data type of the `samm:exampleValue` must
be convertible to the effective data type of the Property's Characteristic. For example, if the
Characteristic's `samm:dataType` is `xsd:int`, `xsd:short` is also a valid type for the
`samm:exampleValue`. Refer to section xref:datatypes.adoc#implicit-conversions[Implicit Conversions]
for more details. | {nok}
|===

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=property-declaration]
----

[[declaring-characteristics]]
=== Declaring Characteristics

The attributes for Characteristics are described in detail in section
xref:characteristics.adoc#characteristics[Characteristics].

The `dataType` attribute may be omitted when creating a subclass of a Characteristic. The `dataType`
attribute must be set when creating an instance of a Characteristic, except when the `dataType`
attribute has been set in the class or one of the super-classes. When the `dataType` has been set in
a superclass, the `dataType` may be set to a subclass of the `dataType` from one of the
Characteristic superclasses. This allows the definition of generic Characteristics such as
Collections, where all the semantics are fixed, except for the data type. For a Collection for
example it is possible to define whether the collection is sorted or not and this definition can be
then reused with different data types to define different collections.

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=state-declaration]
----

[[declaring-quantifiable-values-and-measurements]]
==== Declaring Quantifiables and Measurements

Whenever a Property represents a numeric, scalar value that the result of a measurent of some kind
(e.g., using a sensor) and has a well-defined physical unit which is known at modeling time, use the
_Measurement_ Characteristic. If the value is numeric and has a physical unit but is not the result
of a measurement (e.g., when it is calculated from other values), use the _Quantifiable_
Characteristic.

See the following example that uses _Measurement_ -- usage of _Quantifiable_ is analogous.

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=measurement-declaration]
----
See section xref:units.adoc#units[Units] for information about the valid values for the `samm-c:unit` attribute.

[[declaring-single-entity]]
==== Declaring Single Entity

The following example shows how a Property is defined that uses the
xref:characteristics.adoc#single-entity-characteristic[Single Entity] Characteristic to specify an Entity as its dataType.

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=single-entity-declaration]
----

[[declaring-collections]]
==== Declaring Collections

There are four basic predefined types of Collections:
xref:characteristics.adoc#collection-characteristic[Collection],
xref:characteristics.adoc#list-characteristic[List],
xref:characteristics.adoc#set-characteristic[Set] and
xref:characteristics.adoc#sortedset-characteristic[Sorted Set]. The Collection definitions are
shared and are available globally. They determine whether a specific collection is ordered or not
and whether a specific collection may contain duplicates or not. In some cases the data type is also
set in the shared Collection Characteristic.

These shared Collection Characteristics may not be changed in an Aspect Model, hence it is not
allowed to create a subclass of the Collection Characteristic in an Aspect Model. To create a
Collection Characteristic for a specific domain, the user should instantiate one of the Collection
classes and define the data type or the element Characteristic for the Collection. In this example,
the Characteristic resulting from the combination of Code, Length Constraint and Encoding Constraint
is not defined inline in the Property, but defined standalone.

[cols="a,a"]
|====
| Example with a scalar data type:
[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=scalar-collection]
----
| Example with a custom Entity as data type:
[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=entity-collection]
----
|====

TIP: The data type for the elements of a Collection can either be defined in the usual manner using
the `samm:dataType` attribute (see the examples above) or by defining a Characteristic for the
Collection elements using the `samm-c:elementCharacteristic` attribute, see the example below. It is
recommended to explicitly create a Characteristic for the Collection elements instead of only
defining the data type, since it allows to completely express the semantics of the elements.

Example with the `samm-c:elementCharacteristic` attribute:
[source,turtle,subs="attributes+"]
----
include::example$collection-with-element-characteristic.ttl[tags=content]
----

[[declaring-enumerations]]
==== Declaring Enumerations

Describes a Property which may have a value from a predefined list of values. Also see
xref:characteristics.adoc#enumeration-characteristic[Enumeration].

Example with literal `xsd:string` values:
[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=enumeration-simple-declaration-string]
----

Example with literal `xsd:integer` values. Note that for `xsd:integer`, Turtle's numeric literal
syntax can be used:
[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=enumeration-simple-declaration-integer]
----

Example with literal `xsd:int` values:
[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=enumeration-simple-declaration-int]
----

Example with literal `xsd:date` values:
[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=enumeration-simple-declaration-date]
----

[[enumeration-with-complex-value]]
Example with complex values:

Declaring an Enumeration with a complex value is usally done in order to add a description to the
actual value, e.g., the `state` in the example below, which provides information regarding the
meaning of the value. This description only exists in the Aspect Model and is not part of the
payload provided by an Aspect at runtime. In order to define that a Property of an Entity is _not_
part of the runtime data, the `samm:notInPayload` attribute is used.

NOTE: `samm:notInPayload` cannot be used in Abstract Entities, but the setting for a specific property
is inherited when Entities are extended.

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=enumeration-complex-declaration]
----

CAUTION: If the Property is part of the runtime data (like `status` in the example), it is directly
referenced. Writing `samm:notInPayload false` is _not_ allowed.

[[declaring-state]]
==== Declaring State

As described in xref:characteristics.adoc#state-characteristic[State Characteristic], State inherits
from Enumeration and extends it with the default value attribute.

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=state-declaration]
----

[[declaring-time-series]]
==== Declaring Time Series

The `xref:characteristics.adoc#time-series-characteristic[TimeSeries]` Characteristic is a special
kind of Collection. A Time Series is defined as a list of tuples of values with their respective
specific point in time when they where recorded. This is, the Time Series is represented by a list
of key/value pairs where the key is the time-stamp denoting when the value was recorded and the
value is the recorded value. In order to describe these semantics the shared `TimeSeries`
Characteristic is used. This is a subclass of the `SortedSet` Characteristic and defines that the
`dataType` must be a subclass of the `TimeSeriesEntity`.

The `xref:entities.adoc#time-series-entity[TimeSeriesEntity]` is declared as an Abstract Entity. It
defines the `timestamp` Property with the `Timestamp` Characteristic, which describes values
containing timestamps conforming to `xref:datatypes.adoc#data-types[xsd:dateTime]`, a date and time
with or without time zone. It also defines `value` as an
xref:modeling-guidelines.adoc#abstract-entities-with-abstract-properties[Abstract Property], i.e., a
Property without a Characteristic.

To create a Time Series for a specific domain, the user should instantiate the `TimeSeries`
Collection Characteristic and set the `dataType` to an Entity which extends the Abstract
`TimeSeries` Entity in order to define the semantics for the `value` Property in the context of the
specific domain. Please see the xref:modeling-guidelines.adoc#declaring-abstract-entities[Declaring
Abstract Entities] section for information on how to extend an Abstract Entity.

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tag=timeseries-declaration]

include::example$aspect-sample.ttl[tag=state-declaration]
----

TIP: An Aspect should only have one Collection at root level. When modeling an Aspect with two or
more collections at root level which contain related data, consider creating the model so that the
related data is explicitly linked and contained in a single Collection. When modeling an Aspect with
two or more collections at root level which contain unrelated data, consider creating separate
Aspects each containing a single Collection.

[[declaring-quantities]]
==== Declaring Quantities

The `xref:characteristics.adoc#unit-reference-characteristic[UnitReference]` Characteristic is used
to associate numeric values with their respective physical units in a structured and explicit way.
The `Quantity` Entity is designed to represent such a pairing, ensuring that values are always
interpreted correctly with their corresponding units.

A `Quantity` is defined as an entity that contains a numeric `value` and a corresponding `unit`,
both of which are essential for properly interpreting the data.
The `xref:entities.adoc#quantity-entity[QuantityEntity]` is declared as an Abstract Entity,
providing a standard way to associate measurements with units.

To describe these semantics, the `Quantity` Entity defines the `value` Property as
an `xref:modeling-guidelines.adoc#abstract-entities-with-abstract-properties[Abstract Property]`,
meaning it does not have an inherent Characteristic and must be specialized based on the context.
The `unit` Property is assigned the `xref:characteristics.adoc#unit-reference-characteristic[Unit Reference]`
Characteristic, which ensures that it references a recognized unit of measurement.

To define a Quantity for a specific domain, the user should instantiate an Entity that extends
the Abstract `Quantity` Entity and provide a specialized Characteristic for the `value` Property,
specifying its data type and semantics according to the domain's needs. For details on how to extend
an Abstract Entity, please refer
to the `xref:modeling-guidelines.adoc#declaring-abstract-entities[Declaring Abstract Entities]` section.

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tag=quantity-declaration]
----

[[declaring-either]]
==== Declaring Either

Describes a Property whose value can have one of two possible types (a disjoint union). This
Characteristic is special since it does not directly define a data type. The data type is defined in
the two Characteristics which define the left and right value of the disjoint union. Also see
xref:characteristics.adoc#either-characteristic[Either] and xref:payloads.adoc#characteristics-payload-mappings[Payload mappings to JSON for Characteristics].

Example:

[source,turtle,subs="attributes+"]
----
include::example$either-declaration.ttl[tags=either-declaration]
----

[[declaring-structured-value]]
==== Declaring Structured Value

xref:characteristics.adoc#structured-value-characteristic[Structured Values] are intended to be used
for Properties when all of the following conditions are met:

* The value has a scalar, xref:datatypes.adoc#data-types[string-like value space]
* The value has a well-known structure consisting of different, separate parts
* The parts can and should be described in more detail
* The Property should not be decomposed/deconstructed into an Entity with separate Properties for
  each part

One of the main use cases is complex identifiers that encode context information such as provenance
information, version numbers, locations codes and so on. It is unreasonable to split such a value up
into separate Properties, because it complicates working with corresponding data. For example, such
values could appear in payloads, databases or documents and would have to be converted back and
forth, often times manually. On the other hand, properly describing the value and the parts it
comprises can be difficult, especially in a machine-readable way.

Therefore, the Structured Value Characteristic can be used to describe the deconstruction of a value
into its parts and linking each part to a separate Property definition.

The following table gives some simple examples to demonstrate the basic applicability of the
Characteristic, and after that a complete concrete example is given.

[width="100%", options="header"]
|===
| Name | Example Value | Deconstruction Rule | Elements
| ISO 8601 date | "2019-09-27"^^`xsd:date` | `(\d\{4})-(\d\{2})-(\d\{2})` | ( `:year` "-" `:month`
  "-" `:day` )
| Email Address | "\user4711@example.com" | `([\w\.-]+)@([\w\.-]+\.\w{2,4})` | ( `:username` "@" `:host` )
| Hex-encoded color | "0xAC03BE" | `0x([0-9A-Fa-f]\{2})([0-9A-Fa-f]\{2})([0-9A-Fa-f]\{2})` | ( "0x"
  `:red` `:green` `:blue` )
|===

The following code shows the Aspect Model for the first example from the table. Note that when
writing the `deconstructionRule`, backslashes (`\`) need to be escaped in order to produce valid
RDF/Turtle syntax, i.e. write `\\` instead of `\`.

:attribute-missing: skip
[source,turtle,subs="attributes+"]
----
include::example$structured-value-sample.ttl[tags=content]
----
:attribute-missing: warn

NOTE: Technically, `samm-c:elements` would not be required just to parse corresponding payload; the
regular expression given in the `samm-c:deconstructionRule` would be sufficient. However, the
`elements` fields serves two purposes: Firstly, it concisely describes how the meaning of the
deconstruction rule corresponds with the named fields; secondly, it is used for validation: When a
`samm:exampleValue` is given (like in the example), the Aspect Model validator can automatically
check if it can be deconstructed using the deconstruction rule and reconstructed using the elements,
i.e., that the deconstruction rule actually does what the model author intended.

[[declaring-reference]]
==== Declaring Reference

The xref:characteristics.adoc#reference-characteristic[Reference] Characteristic is intended to be used
for scenarios where a reference to a concept external to the Aspect Model is required, but the value of the
reference (i.e., the identifier of the linked concept) is not known at modeling time yet. Other than that,
it is conceptually similar to a xref:modeling-guidelines.adoc#adding-external-references[samm:see reference].

:attribute-missing: skip
[source,turtle,subs="attributes+"]
----
include::example$reference-declaration.ttl[tags=content]
----
:attribute-missing: warn

[[using-unit-reference]]
==== Using Unit Reference

As explained in the section xref:modeling-guidelines.adoc#declaring-quantifiable-values-and-measurements[Declaring Quantifiables and Measurements], some values only make sense when they also have a unit assigned to them.
This unit definition is in many cases fixed at design time, does not change thereafter and therefore at runtime (in the JSON payload for example), only the actual value is transported. +
 There may be scenarios, however, where this permanent fixation on a specific unit might not be sufficient because the unit can only be determined dynamically
at runtime, or is a kind of configuration parameter which must be set when the system is being deployed/starting up. In cases like this, a xref:characteristics.adoc#unit-reference-characteristic[UnitReference] characteristic instance can be used to include a dynamic reference to the desired unit from the xref:appendix:unitcatalog.adoc[Unit catalog] and this information is then always included in the payload. The runtime payload refers to the unit using its `samm:curie`, i.e., the unit's URN's element name prefixed with `unit:`.

For example an Aspect with the following model:

[source,turtle,subs="attributes+"]
----
include::example$unit-reference.ttl[tags=content]
----

can produce a JSON payload that could look something like this:

[source,json,subs="attributes+"]
----
{
  "value" : 2.25,
  "unit" : "unit:hectopascal" 
}
----

[[declaring-constraints]]
=== Declaring Constraints and Traits

Consider the `numbers` Property that uses an instance of the `List` Characteristic:

[source,turtle,subs="attributes+"]
----
include::example$regular-numberlist.ttl[tags=content]
----

To add a xref:characteristics.adoc#length-constraint[Length Constraint] to the list, replace the use
of the Characteristic with a new xref:characteristics.adoc#trait-characteristic[Trait] instance. Set
the original Characteristic as the Trait's `samm-c:baseCharacteristic` and add the required
Constraint as a `samm-c:constraint` to the Trait:

[source,turtle,subs="attributes+"]
----
include::example$constrained-numberlist.ttl[tags=content]
----

Another more complex example is given below. The Property `someIdentifier` is defined that uses a
xref:characteristics.adoc#code-characteristic[Code] instance using a dataType of `xsd:string`,
combined with two Constraints: an xref:characteristics.adoc#encoding-constraint[Encoding Constraint]
that restricts the value space to US-ASCII and a xref:characteristics.adoc#length-constraint[Length
Constraint] that limits the string to 80 characters.

:attribute-missing: skip
[source,turtle,subs="attributes+"]
----
include::example$constrained-stringcode.ttl[tags=content]
----
:attribute-missing: warn

An example showing the xref:characteristics.adoc#regular-expression-constraint[Regular Expression Constraint] is given below:

:attribute-missing: skip
[source,turtle,subs="attributes+"]
----
include::example$constrained-stringcode.ttl[tags=regular-expression-sample]
----
:attribute-missing: warn

NOTE: When writing the `samm:value`, backslashes (`\`) need to be escaped in order to produce valid RDF/Turtle syntax, i.e. write `\\` instead of `\`.

[[declaring-entities]]
=== Declaring Entities

Entities have the following attributes:

[width="100%", options="header"]
|===
| Attributes | Description | Required
| `samm:properties` | The list of Properties which make up the Entity. Leaving out this
  attribute completely is equivalent to having it present with an empty list as value.| {nok}
| `samm:extends` | The Entity which is extended by this Entity | {nok}
|===

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=entity-declaration]
----

[[extending-entities]]
==== Extending Entities

Declaring that an Entity extends another Entity is done using the `samm:extends` attribute in the Entity declaration.

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=extending-entity-declaration]
----

The extending Entities `:Student` and `:Teacher` contain the Properties declared in the extended Entity `:Person` as well as
the Properties in their own declarations.

The effective Property names, i.e. the payload name when `samm:payloadName` is used, or the name of the Property,
must be unique across the entire Entity inheritance chain. Otherwise the corresponding runtime payload is ambiguous.

When one of the attributes xref:modeling-guidelines.adoc#payload-names[samm:payloadName],
xref:modeling-guidelines.adoc#optional-properties[samm:optional] or `samm:notInPayload` is used on a specific property usage,
its value is also inherited by the extending Entities. Using the example of `samm:payloadName`,
we could modify the above example to enforce the alternative naming for the `surname` property in the generated payloads
and this change would apply to the `Person` Entity (directly) and both `Student` and `Teacher` Entities (via inheritance):

[source,turtle,subs="attributes+"]
----
include::example$extending-entity-declaration-inheritance.ttl[tags=extending-entity-declaration-inheritance]
----

[[declaring-abstract-entities]]
==== Declaring Abstract Entities

In contrast to Entities, Abstract Entities cannot directly be instantiated. A Characteristic class may have a type `samm:entity` or `samm:AbstractEntity`. But a Characteristic instance cannot have a type `samm:AbstractEntity`. If there is an instance created from a Characteristic that uses an Abstract Entity as its type, this Characteristic instance's dataType must be a sub-Entity of the Abstract Entity.
The main use case for Abstract Entities is to share Properties across multiple Entities. This can be achieved through inheritance: Abstract Entities can extend other Entities and Abstract Entities and can themselves be extended in a manner not dissimilar to how abstract classes are used in many programming languages.

In the following example, both `SteeringWheel` and `Seat` _extend_ the Abstract Entity
`VehicleComponent`. Both inherit the `typeNumber` and the `manufacturer` Properties:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=abstract-entity-declaration]
----

[[abstract-entities-with-abstract-properties]]
==== Abstract Entities with Abstract Properties

When an Abstract Entity needs to be defined with a certain Property, but the modeler using the
Abstract Entity (i.e., extending it) should be able to decide the Property's Characteristic, the
Property can be declared a `samm:AbstractProperty`. An Abstract Property is similar to a Property,
with two differences: firstly, it has no `samm:Characteristic` attribute and secondly, it must only
be used in Abstract Entities. Consider the following example of two-dimensional vector which is
declared as an Abstract Entity using two Abstract Properties for its `x` and `y` values, leaving for
the user to decide which Characteristic and hence which data type should be used:

[source,turtle,subs="attributes+"]
----
include::example$abstract-property-sample.ttl[tags=abstract-entity-with-abstract-property-declaration]
----

The usage of the Abstract Properties allows to specify the contract (a two-dimensional vector must
have x and y Properties), but allows flexible reuse. Only when it is used, one must decide on the
Characteristic and with it its effective datatype such as `xsd:int`, `xsd:float` or `xsd:decimal`.

To use the `Vec2` Abstract Entity, the Characteristic to bind to the Abstract Properties is declared
and then used as follows:

[source,turtle,subs="attributes+"]
----
include::example$abstract-property-sample.ttl[tags=abstract-entity-with-abstract-property-usage]
----

Note that an Abstract Entity can have both `samm:Property`&#8203;s and
`samm:AbstractProperty`&#8203;s (both are listed in `samm:properties`). The properties list of an
Entity that extends the Abstract Entity must specify the Characteristic to use for each of the
Abstract Properties (and only those).

[[declaring-operations]]
=== Declaring Operations

Operations have the following attributes:

[width="100%", options="header"]
|===
| Attributes | Description | Required
| `samm:input` | A list of references to Properties that describe the input to the operation. The
  attribute must be present, but the list may be empty. | {ok}
| `samm:output` | A single reference to a Property that describes the output of the operation. |
  {nok}
|===

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=operation-declaration]
----

[[declaring-events]]
=== Declaring Events

Events have the following attributes:

[width="100%", options="header"]
|===
| Attributes | Description | Required
| `samm:parameters` | The parameters that describe the Event, given as a list of Properties.| {ok}
|===

Example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=event-declaration]

include::example$aspect-sample.ttl[tags=measurement-declaration]
----

[[adding-external-references]]
=== Adding external references

The `samm:see` attribute can be used to add references to related elements in an external taxonomy,
ontology or standards document to Aspect Model elements. Values for `samm:see` must be URIs. The
meaning of the reference is informative and implies no semantics such as equality or subsumption in
either direction.

In the following example, `samm:see` adds two references to external well-known vocabularies that
have identifiers which are also valid URLs:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=see-url-declaration]
----

If an external model element should be referenced that has a unique identifier which is not a URI,
but a well-known resolver exists, you can either use the resolver's URL or a synthetic URN. For
example, for the Digital Object Identifier (DOI,
xref:samm-specification:appendix:bibliography.adoc#doi[[DOI\]]) `10.1109/NetSys.2017.7903949`, you can
use as the value for `samm:see` either the URL `\https://doi.org/10.1109/NetSys.2017.7903949` or the
URN `urn:doi:10.1109/NetSys.2017.7903949`.

If an external model element should be referenced that has a unique identifier which is not a URI
and there is no well-known resolver, use a synthetic URN structure. One example are Object
Identifiers as specified by ITU and ISO/IEC (OID) and the mapping to URNs in RFC 3061
xref:samm-specification:appendix:bibliography.adoc#rfc3061[[rfc3061\]], so for example, for the OID
`1.3.6.1.4.1.1919.1.1.2`, the corresponding `samm:see` value would be
`urn:oid:1.3.6.1.4.1.1919.1.1.2`:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=see-oid-declaration]
----

If an external element should be referenced that has no unique identifier, `samm:see` should not be
used. In this case, refer to the external element in the current model element's `samm:description`,
for example:

[source,turtle,subs="attributes+"]
----
include::example$aspect-sample.ttl[tags=see-dontuse]
----

[[optional-properties]]
=== Optional Properties

When Properties are used in Aspects and Entities, they can be marked as optional (not possible for properties of Abstract Entities). This means that a
Property's _usage_ is optional, not the Property itself, which would make reusing a Property more
difficult. In the following example, the Property `toggleStatus` is mandatory and the Property
`errorMessage` is marked as optional in the Aspect. Note how the `samm:properties` of the Aspect are
defined, and how the definition for the `toggleStatus` Property itself does not differ from that of
`errorMessage`.

[source,turtle,subs="attributes+"]
----
@prefix : <urn:samm:{example-ns}.myapplication:1.0.0#> .
@prefix samm: <{samm}> .
@prefix samm-c: <{samm-c}> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

include::example$optional-properties-sample.ttl[tags=optional-properties-declaration]
----

CAUTION: If the Property's use is optional, it is marked with `samm:optional true` (like
`errorMessage` in the example). However, if its use is mandatory (like `toggleStatus` in the
example), the Property is directly referenced. Writing `samm:optional false` is _not_ allowed.

NOTE: The setting of the `samm:optional` attribute for a specific property is inherited from parent Entity
by the Entities extending it using the Entity extension mechanism (`samm:extends`).

[[payload-names]]
=== Declaring Payload Names for Properties

When Properties are used in Aspects and Entities, a runtime payload name can be defined for the
Property. This means that in the context of the Aspect or Entity (payload names cannot be defined for Abstract Entities) where the Property is used, the key
of that Property in the runtime payload diverges from the Property's local name. This allows for
the separation of the semantic name of the Property and the corresponding key in the runtime
payload. In the following example we define a Property `errorMessage`. In the Aspect it is defined
that the corresponding key in the payload is `error`.

NOTE: The value for the `samm:payloadName` attribute must be of type `xsd:string`.

[source,turtle,subs="attributes+"]
----
@prefix : <urn:samm:{example-ns}.myapplication:1.0.0#> .
@prefix samm: <{samm}> .
@prefix samm-c: <{samm-c}> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

include::example$payload-name-sample.ttl[tags=payload-name-declaration]
----

CAUTION: A Property must not be marked as not being included in the payload using `samm:notInPayload
true` and have a payload name declared using `samm:payloadName`.

NOTE: It is also useful to know that the payload name definition is inherited from parent Entity
by its children when using the Entity extension mechanism (`samm:extends`).

[[syntactic-shortcuts]]
=== Syntactic Shortcuts

When Properties use Characteristics classes, i.e. Characteristics that need to be instantiated, and
the Characteristic instance is used in only one Property, the Characteristic may also be defined
inline. Note that other Aspect Models can not refer to the Characteristic any more, because it no
longer has an identifier.

[cols="a,a"]
|====
| Example: Regular definition of a Property
[source,turtle,subs="attributes+"]
----
include::example$regular-numberlist.ttl[tags=content]
----
| Example: Inlining the Characteristic definition
[source,turtle,subs="attributes+"]
----
include::example$inline-numberlist.ttl[tags=content]
----
|====

== Localization of Aspect Models

To understand the possibilities for localization of the models and their implications it is important to understand the differences
between the data types `xsd:string` and `rdf:langString` and/or their respective characteristic
counterparts `samm-c:Text` and `samm-c:MultiLanguageText`.

To illustrate the differences between them and to give a typical example for localizable string
that also needs to be included in the runtime payload, consider this model with a scalar `text` property:

[source,turtle,subs="attributes+"]
----
include::example$localization-samples.ttl[tags=simple-text]
----

The JSON payload for this model would then look like this:

[source,json]
----
{
  "text" : "My value"
}
----

Notice how the text is just a raw string, without any information about the language it is written in.
When instead the `text` property is modeled as `samm-c:MultiLanguageText` (instead of `samm-c:Text`),
the payload would change to include the information about the language and would look like this:

[source,json]
----
{
  "text" : {
    "en" : "Example multi language string"
  }
}
----

Another common use case is the use of localized texts strictly for documentation purposes. This means that the multilanguage strings
can only be seen when modeling, they are not contained in the runtime payloads.

To illustrate how this is done, consider xref:modeling-guidelines.adoc#enumeration-with-complex-value[this example]
and imagine we would like the descriptions of the possible enumeration values to have localized version of the texts.
This goal could be achieved by extending the model to look something like the following example:

[source,turtle,subs="attributes+"]
----
include::example$localization-samples.ttl[tags=enum-example]
----

Note the use of the attribute `notInPayload` in usage of the property, ensuring that the `description`
property will never be included in the runtime payloads.

It is even possible to provide the description in multiple languages.
To achieve this, we need to change the type of the `description` property to the Set Characteristic:

[source,turtle,subs="attributes+"]
----
include::example$multi-lang-example.ttl[tags=multi-lang-example]
----

Notice how it is now possible to use the `description` property with multiple texts with different language tags (`@de`) to achieve the proper localization of the texts
for linguistically diverse audiences.

